---
templateKey: blog-post
title: ğŸš• 7 ìš°ë²„ í´ë¡  ì½”ë”© (nomad coders)
date: 2019-04-17T08:56:56.243Z
description: ìš°ë²„ ì½”ë”© ê°•ì˜ ë¡œê·¸ 1.34 ~ 1.38
featuredpost: true
featuredimage: /img/nuber_clone.jpg
tags:
  - nomad coders
  - ìš°ë²„ í´ë¡  ì½”ë”©
---
# 

## #1.34 Introduction to Twilio

ì´ë²ˆì—ëŠ” íœ´ëŒ€í°ìœ¼ë¡œ ë¬¸ì ì¸ì¦ ì„œë¹„ìŠ¤ë¥¼ ì‚¬ìš©í•˜ê¸° ìœ„í•´ Twilio ì„œë¹„ìŠ¤ë¥¼ ì‚¬ìš©í•  ê²ƒì´ë‹¤. ì´ ì„œë¹„ìŠ¤ëŠ” ìœ ë£Œì§€ë§Œ ê·¸ëŸ¬ê²Œ ë¶€ë‹´ìŠ¤ëŸ½ì§€ ì•Šì€ ê°€ê²©ìœ¼ë¡œ í•„ìš”í•œ ì¸ì¦ ì„œë¹„ìŠ¤ë¥¼ ì œê³µí•  ê²ƒì´ë‹¤.

[https://twilio.com](https://twilio.com) ì— ì ‘ì†í•´ì„œ íšŒì›ê°€ì…ì„ í•œ í›„ ë²ˆí˜¸ë¥¼ í•˜ë‚˜ ë°œê¸‰ ë°›ëŠ”ë°, ê¼­ ë¯¸êµ­ ë²ˆí˜¸ë¡œ ë°œê¸‰ ë°›ì•„ì•¼ í•œë‹¤. ë°œê¸‰ ë°›ëŠ”ë° ë¹„ìš©ì€ $1 ë‹¤. ì´ê²Œ ì–´ë–»ê²Œ ë‚´ëŠ” ê²ƒì¸ì§€ ì˜ ëª¨ë¥´ê² ì§€ë§Œ,,

[https://www.twilio.com/console/sms/settings/geo-permissions](https://www.twilio.com/console/sms/settings/geo-permissions) ì—¬ê¸°ì„œ ëª¨ë“  ì²´í¬ë¥¼ í•´ì¤˜ì•¼í•œë‹¤. ì²´í¬ë¥¼ ì•ˆí•œ êµ­ê°€ë¡œëŠ” SMSê°€ ì•ˆê°ˆ ìˆ˜ ìˆë‹¤.

![](_2019-04-15__10-822931a5-36bf-46d2-a359-9991bd748e7e.28.40.png)

ëŒ€ì‰¬ë³´ë“œì—ì„œ í† í°ì„ í™•ì¸í•  ìˆ˜ ìˆë‹¤.

![](_2019-04-15__10-c3b0b3d6-ef7f-4103-b21b-025b51d47545.29.18.png)

## #1.35 StartPhoneVerification Resolver part One

twilioë¥¼ í†µí•´ í°ì¸ì¦ì„ êµ¬í˜„í•  ê²ƒì¸ë°, ì•ì„œ twilio ì¸ì¦ ì •ë³´ë¥¼ `.env`ì— ì¶”ê°€í•˜ì.

- src/.env íŒŒì¼ì— TWILIO_SID, TWILIO_PHONE, TWILIO_TOKENì„ ì¶”ê°€í•˜ì.

        ...
        TWILIO_SID=AC1fe68ff538d041200e74b814eb015e41
        TWILIO_PHONE=+13347588283
        TWILIO_TOKEN=

ì´ë²ˆì—ëŠ” Verification entityì—ì„œ User, usedë¥¼ ì œê±°í•  ê²ƒì¸ë°, ê·¸ ì´ìœ ëŠ” ìµëª… ìœ ì €ì¼ ë•Œ ë¬´ì–¸ê°€ ë¬¸ì œê°€ ë˜ëŠ” ê²ƒ ê°™ë‹¤. usedëŠ” ì‚¬ìš©ì´ ëë‚œ Verificationì€ ì‚­ì œí•  ê²ƒì´ë¯€ë¡œ ì´ í•„ë“œê°€ í•„ìš”ê°€ ì—†ë‹¤.

- src/api/Verification/shared/Verification.graphql

        type Verification {
          id: Int!
          target: String!
          payload: String!
          key: String!
          createAt: String!
          updateAt: String
        }

- src/api/User/shared/User.graphql

        type User {
          id: Int!
          email: String
          verifiedEmail: Boolean!
          firstName: String!
          lastName: String!
          age: Int
          password: String
          phoneNumber: String
          verifiedPhoneNumber: Boolean!
          profilePhoto: String
          createAt: String!
          updateAt: String
          fullName: String
          chat: Chat
          messages: [Message]
          ridesAsPassenger: [Ride]
          ridesAsDriver: [Ride]
          isDriving: Boolean!
          isRiding: Boolean!
          isTaken: Boolean!
          lastLng: Float
          lastLat: Float
          lastOrientation: Float
          fbId: String
        }
        
        type Query {
          user: User
        }

- src/entities/Verification.ts

        import {
          BaseEntity,
          BeforeInsert,
          Column,
          CreateDateColumn,
          Entity,
          PrimaryGeneratedColumn,
          UpdateDateColumn,
         } from 'typeorm'
        import { verificationTarget } from 'src/types/types';
        
        const PHONE = "PHONE";
        const EMAIL = "EMAIL";
        
        @Entity()
        class Verification extends BaseEntity {
          @PrimaryGeneratedColumn() id: number;
        
          @Column({ type: "text", enum: [EMAIL, PHONE]})
          target: verificationTarget;
        
          @Column({ type: "text"})
          payload: string;
        
          @Column({ type: "text"})
          key: string;
        
          @CreateDateColumn() createAt: string;
          @UpdateDateColumn() updateAt: string;
        
          @BeforeInsert()
          createKey(): void {
            if(this.target === PHONE) {
              this.key = Math.floor(Math.random() * 10000).toString();
            } else if(this.target === EMAIL) {
              this.key = Math.random().toString(36).substr(2);
            }
          }
        }
        
         export default Verification;

- src/entities/User.ts

        import bcrypt from 'bcrypt';
        import { IsEmail } from 'class-validator';
        import { 
          BaseEntity, 
          BeforeInsert,
          BeforeUpdate,
          Column, 
          CreateDateColumn,
          Entity,
          ManyToOne,
          OneToMany, 
          PrimaryGeneratedColumn,
          UpdateDateColumn,
        } from 'typeorm';
        import Chat from './Chat';
        import Message from './Message';
        import Ride from './Ride';
        
        const BCRYPT_ROUNDS = 10;
        
        @Entity()
        class User extends BaseEntity {
          @PrimaryGeneratedColumn() id: number;
        
          @Column({ type: "text", nullable: true})
          @IsEmail()
          email: string | null;
        
          @Column({ type: "boolean", default: false})
          verifiedEmail: boolean;
        
          @Column({ type: "text"})
          firstName: string;
        
          @Column({ type: "text"})
          lastName: string;
        
          @Column({ type: "int", nullable: true})
          age: number;
          
          @Column({ type: "text", nullable: true})
          password: string;
        
          @Column({ type: "text", nullable: true})
          phoneNumber: string;
        
          @Column({ type: "boolean", default: false})
          verifiedPhoneNumber: boolean;
        
          @Column({ type: "text"})
          profilePhoto: string;
        
          @ManyToOne(type => Chat, chat => chat.participants)
          chat: Chat;
        
          @OneToMany(type => Message, message => message.user)
          messages: Message[];
        
          @OneToMany(type => Ride, ride => ride.passenger)
          ridesAsPassenger: Ride[];
        
          @OneToMany(type => Ride, ride => ride.driver)
          ridesAsDriver: Ride[];
        
          @Column({ type: "boolean", default: false})
          isDriving: boolean;
        
          @Column({ type: "boolean", default: false})
          isRiding: boolean;
        
          @Column({ type: "boolean", default: false})
          isTaken: boolean;
        
          @Column({ type: "double precision", default:0})
          lastLng: number;
        
          @Column({ type: "double precision", default:0})
          lastLat: number;
          
          @Column({ type: "double precision", default:0})
          lastOrientation: number;
        
          @Column({ type: "text", nullable: true})
          fbId: string;
        
          public comparePassword(password: string): Promise<boolean> {
            return bcrypt.compare(password, this.password);
          }
        
          get fullName() : string {
            return `${this.firstName} ${this.lastName}`
          }
        
          @CreateDateColumn() createAt: string;
        
          @UpdateDateColumn() updateAt: string;
        
          private hashPassword(password: string): Promise<string> {
            return bcrypt.hash(password, BCRYPT_ROUNDS);
          }
        
          @BeforeInsert()
          @BeforeUpdate()
          async savePassword() : Promise<void> {
            if(this.password) {
                const hashedPassword = await this.hashPassword(this.password);
                this.password = hashedPassword;
            }
          }
        }
        
        export default User;

ê·¸ë¦¬ê³  twilio ëª¨ë“ˆì„ ì„¤ì¹˜í•˜ì—¬ ì†ì‰½ê²Œ ì‚¬ìš©í•˜ì.

    $ yarn add twilio
    $ yarn add @types/twilio --dev

- src/api/User/StartPhoneVerification/StartPhoneVerification.graphql

        type StartPhoneVerificationResponse {
          ok: Boolean!
          error: String
        }
        
        type Mutation {
          StartPhoneVerification(phoneNumber: String!): StartPhoneVerificationResponse!
        }

    graphql typeì„ ìƒì„±í•œ í›„ yarn types ë¡œ src/types/graphì— ì¶”ê°€ë˜ë„ë¡ í•˜ì.

- src/api/User/StartPhoneVerification/StartPhoneVerification.resolvers.ts

        import { Resolvers } from 'src/types/resolvers';
        import { 
          StartPhoneVerificationMutationArgs, 
          StartPhoneVerificationResponse 
        } from 'src/types/graph';
        import Verification from '../../../entities/Verification';
        
        const resolvers: Resolvers = {
          Mutation: {
            StartPhoneVerification: async (
              _, 
              args: StartPhoneVerificationMutationArgs
            ) : Promise<StartPhoneVerificationResponse> => {
              const { phoneNumber } = args;
              try {
                const existingVerification = await Verification.findOne({ 
                  payload: phoneNumber 
                });
                if(existingVerification) {
                  existingVerification.remove();
                }
        
              } catch(error) {
                return {
                  ok: false,
                  error: error.message
                }
              }
            }
          }
        }
        
        export default resolvers;

    ì•„ì§ ë¦¬í„´ê°’ì„ ì •ì˜í•˜ì§€ì•Šì•„ì„œ íƒ€ì… ì˜¤ë¥˜ê°€ ë°œìƒí•œë‹¤. ì´ê±´ ì•„ë˜ì—ì„œ ë” ì±„ìš´ë‹¤.

## #1.36 StartPhoneVerification Resolver part Two

- src/utils/sendSMS.ts ìœ„ ê°•ì˜ì— ì´ì–´ì„œ Twilioë¡œ SMSì„ ë³´ë‚´ëŠ” ìœ í‹¸ íŒŒì¼ì„ ì¶”ê°€í•  ê²ƒì´ë‹¤.

        import Twilio from 'twilio';
        
        const { TWILIO_SID, TWILIO_TOKEN, TWILIO_PHONE } = process.env;
        
        const twilioClient = Twilio(TWILIO_SID, TWILIO_TOKEN);
        
        const snedSMS = (to: string, body: string) => {
          return twilioClient.messages.create({
            body,
            to,
            from: TWILIO_PHONE
          });
        };
        
        export const sendVerificationSMS = (to: string, key: string) => 
          snedSMS(to, `Your verification key is : ${key}`);

    `snedSMS`: ë©”ì‹œì§€ë¥¼ ë³´ëƒ„

    `sendVerificationSMS`: snedSMSì„ ì´ìš©í•˜ì—¬ ì¸ì¦ ë©”ì‹œì§€ë¥¼ ë³´ëƒ„

- src/api/User/StartPhoneVerification/StartPhoneVerification.resolvers.ts

        import { Resolvers } from 'src/types/resolvers';
        import { 
          StartPhoneVerificationMutationArgs, 
          StartPhoneVerificationResponse 
        } from 'src/types/graph';
        import Verification from '../../../entities/Verification';
        import { sendVerificationSMS } from '../../../utils/sendSMS';
        
        const resolvers: Resolvers = {
          Mutation: {
            StartPhoneVerification: async (
              _, 
              args: StartPhoneVerificationMutationArgs
            ) : Promise<StartPhoneVerificationResponse> => {
              const { phoneNumber } = args;
              try {
                const existingVerification = await Verification.findOne({ 
                  payload: phoneNumber 
                });
                if(existingVerification) {
                  existingVerification.remove();
                }
                const newVerification = await Verification.create({
                  payload: phoneNumber,
                  target: "PHONE"
                }).save();
                await sendVerificationSMS(newVerification.payload, newVerification.key);
                console.log(newVerification);  // ì•„ë˜ì—ì„œ í™•ì¸ í›„ ì§€ìš¸ ë‚´ìš©
        				return {
                  ok: true,
                  error: null
                }
              } catch(error) {
                return {
                  ok: false,
                  error: error.message
                }
              }
            }
          }
        }
        
        export default resolvers;

ì ì´ì œ ì˜¬ë°”ë¡œ ë©”ì‹œì§€ë¥¼ ë³´ë‚´ëŠ”ì§€ í™•ì¸í•´ë³´ì.

[http://localhost:4000/playground](http://localhost:4000/playground) ì—ì„œ ì¿¼ë¦¬ë¥¼ ì‹¤í–‰ì‹œí‚¤ì.

    mutation {
      StartPhoneVerification(phoneNumber: "+82-1033337777") {
        ok
        error
      }
    }

33337777ì€ íœ´ëŒ€í° 010ì„ ì œì™¸í•œ ë²ˆí˜¸ì´ë‹ˆ ê°ì ìì‹ ì˜ ë²ˆí˜¸ë¥¼ ëŒ€ì…í•˜ë©´ ëœë‹¤.

ì˜¬ë°”ë¡œ ë©”ì‹œì§€ë¥¼ ë³´ë‚´ëŠ” ê²ƒì„ í™•ì¸í•˜ì.

![](_2019-04-16__1-7716e11a-8186-449f-92c8-a2f39c84def0.05.44.png)

[README.md](http://readme.md) ì—ì„œ Start Phone Number Verification í•­ëª©ì„ ì™„ë£Œí–ˆë‹¤.

## #1.38 CompletePhoneVerification part One

ì¸ì¦ ì™„ë£Œ ê¸°ëŠ¥ì„ ì§„í–‰í•  í…ë°, ë¨¼ì € ìì„¸í•˜ê²Œ ì–´ë–¤ ìˆœì„œë¡œ ë™ì‘í•˜ëŠ”ì§€ flow chartê°€ ì—†ì–´ì„œ ì„¤ëª…í•˜ëŠ” ê²ƒì´ ì–´ë µë‹¤. ê°•ì˜ì—ë„ ê·¸ëŸ° ë‚´ìš©ì´ ë¨¼ì € ë‚˜ì˜¤ì§€ëŠ” ì•ŠëŠ”ë‹¤. í•˜ì§€ë§Œ ê°•ì˜ë¥¼ ì¢€ ë” ì§„í–‰í•´ì„œ ë‚´ê°€ ë¡œì§ì„ ì´í•´í•˜ë©´ flow chartë¥¼ í¬ìŠ¤íŒ…ì— ì¶”ê°€í•˜ë„ë¡ í•˜ê² ë‹¤.

- src/api/Verification/shared/Verification.graphql ì— verified í•„ë“œë¥¼ ì¶”ê°€í•˜ì.

        ...
        key: String!
        verified: Boolean!
        createAt: String!
        ...

- src/entities/Verification.ts

        ...
        @Column({ type: "text"})
        key: string;
        
        @Column({ type: "boolean", default: false })
        verified: boolean;
        
        @CreateDateColumn() createAt: string;
        ...

- src/api/User/CompletePhoneVerification/CompletePhoneVerification.graphql ComplatePhoneVerification ì´ë¼ëŠ” mutationê³¼ ì‘ë‹µ íƒ€ì…ì„ ì •ì˜í•˜ì.

        type CompletePhoneVerificationResponse {
          ok: Boolean!
          error: String
          token: String
        }
        
        type Mutation {
          CompletePhoneVerification(phoneNumber: String!, key: String!) : CompletePhoneVerificationResponse!
        }

## #1.38 CompletePhoneVerification part Two

ì´ì–´ì„œ resolverë¥¼ ì‘ì„±í•˜ì.

- src/api/User/CompletePhoneVerificationResponse/CompletePhoneVerificationResponse.resolvers.ts

        import Verification from "../../../entities/Verification";
        import User from "../../../entities/User";
        import { 
          CompletePhoneVerificationResponse, 
          CompletePhoneVerificationMutationArgs 
        } from "src/types/graph";
        import { Resolvers } from 'src/types/resolvers';
        
        const resolvers: Resolvers = {
          Mutation: {
            CompletePhoneVerification: async (
              _,
              args: CompletePhoneVerificationMutationArgs
            ) : Promise<CompletePhoneVerificationResponse> => {
              const { phoneNumber, key } = args;
              try {
                const verification = await Verification.findOne({ 
                  payload: phoneNumber,
                  key
                })
                if(!verification) {
                  return {
                    ok: false,
                    error: 'Verification token key not valid',
                    token: null
                  }
                } else {
                  verification.verified = true;
                  verification.save();
                }
              } catch(error) {
                return {
                  ok: false,
                  error: error.message,
                  token: null
                }
              }
        
              try {
                const user = await User.findOne({ phoneNumber });
                if(user) {
                  user.verifiedPhoneNumber = true;
                  user.save();
                  return {
                    ok: true,
                    error: null,
                    token: 'Coming soon'
                  }
                } else {
                  return {
                    ok: true,
                    error: null,
                    token: null
                  }
                }
              } catch(error) {
                return {
                  ok: false,
                  error: error.message,
                  token: null
                }
              }
            }
          }
        }
        
        export default resolvers;

ì´ë²ˆì—ëŠ” StartPhoneVerificationì— ë‚´ í°ë²ˆë¥¼ ì…ë ¥í•´ì„œ ë¬¸ìë¥¼ ë°›ì€ í›„ì— ì•„ë˜ì²˜ëŸ¼ ë‚´ ë²ˆí˜¸ì™€ ë°›ì€ ìˆ«ì 4ìë¦¬ë¥¼ ì…ë ¥í•´ë³´ì. ì˜ ì…ë ¥í–ˆë‹¤ë©´ okê°€ trueë¥¼ ë–¨ì–´ì§ˆ ê²ƒì´ë‹¤. ë˜ í‚¤ë¥¼ ì„ì˜ì˜ ë‹¤ë¥¸ ê°’ìœ¼ë¡œ ë°”ê¿”ë³´ì. ê·¸ëŸ¬ë©´ falseë¥¼ ë¦¬í„´í•˜ëŠ” ê²ƒì„ í™•ì¸í•  ìˆ˜ ìˆë‹¤.

    mutation {
      CompletePhoneVerification(phoneNumber: "+82-1022228888", key: "0000") {
        ok
        error
      }
    }

README.mdì—ì„œ Sign Up with Email í•­ëª©ì´ ì™„ë£Œëë‹¤.